## 函数式编程

### 1.什么是函数式编程？
>functional programming is a programming paradigm—a style of building the structure and elements of computer programs—that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data

来自维基百科的定义，解释道：
函数式编程是一种编程范式用以构建计算机程序结构和元素，用数学函数的标准来评估程序的运算，避免改变状态和可变数据。

从定义我们可以get到两个点：
1. 数学函数的标准是什么标准？
2. 为什么要避免状态和可变数据？

#### 1.1 数学函数的标准
在数学中，函数为两集合间的一种对应关系：输入值集合中的每项元素皆能对应**唯一**一项输出值集合中的元素。例如实数x对应到其平方x*x的关系就是一个函数，若以3作为此函数的输入值，所得的输出值便是9。

这一定义的关键词为【唯一】，表示着如果我有一个函数y=f(x),对于唯一确定的x，我们必定能得到唯一的y。
这一定义又与我们react中常听到的"Pure functions"（纯函数）类似，我们用来判定一个函数是否为纯函数：
- 如果给出相同的参数，它返回相同的结果
- 它不会引起任何可观察到的副作用

Tips: 函数副作用指当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数

#### 1.2 为什么要避免状态和可变数据？
首先，我们来看看一个函数引起状态和数据改变的情况。
```javascript
function fn() {
    let num = 100;
    return function () {
        return num - 1;
    }
}
f = fn();
f();
f();
```
上面这段程序大家都很熟悉，典型的闭包，每次调用f()，函数都会在上一次调用的基础上执行减1操作，很多时候编程中我们需要使用到这样的技巧。

这就是一个典型的函数引起数据改变的例子。乍一看没啥问题，那么如果我们是处于一个并发操作高的环境呢。

如果有100个人，同时请求执行这段代码，我们能预想到实际执行返回结果吗？

很显然，不能，在服务端经常会遇到这种情况，我们常见的解决方案就是【加锁】，一次仅执行一次，那么执行结果就变得可控了。

但是，函数式编程确能很好的解决这个问题，函数式编程的主要思想就是，对于一个确定的操作，我返回唯一的结果，从而保证有迹可循。

通常，我们改变数据和状态的方式是通过赋值。那么可想而知，我们可以大胆地推测函数式编程的核心规则是【避免赋值】。在另一方面，Immutable.js保证数据一旦创建，就不能再被更改，也避免了状态和数据的改变。

### 2.正宗的函数式编程语言——Lisp
Lisp是正宗的函数式编程语言，了解函数式我们不得不究其根源了解一下Lisp。
#### 2.1 Lisp的基本语法
##### 2.1.0 Lisp环境
首先，您需要获得一个LISP解释器(GNU Common Lisp)

Windows 用户安装完了之后，您只需从开始菜单中找到它并单击以运行就可以了。

Linux 用户安装完之后，在终端运行 gcl 即可启动LISP编译环境。
下文中的 > 号表示开始输入指令
##### 2.1.1 表达式（算数表达式）
```
> (+ 1 2) // 3
> (+ 1 2 3 4) // 10
> (+ (*3 3) (* 4 4) ) // 25
```
复杂一点的表达式
```
(+ (*3 (+ (* 2 4) (+3 5) ) ) (+ (-10 7) 6 ) ) // ???
```
Lisp的求值规则：
1. 求各子表达式的值（右值）
2. 将所有右值应用到运算符上就得最终结果
##### 2.1.2 命名（定义）
```
> (define size 5)
> (* size 2) // 10
```
```
> (define (add a b) (+ a b))
> (add 1 2) // 3
```
##### 2.1.3 if
```
> (define (abs x)
    (if (< x 0)
        (- x)
        x
     )
  )
```
##### 2.1.4 递归&迭代(以阶乘为例)
递归
```
(define (factorial n)
    (if (=n 1)
        1
        (* n (factorial (- n 1))
    )
)
```
迭代
```
> (define (factorial n)
    (fact-iter 1 1 n)
) 

> (define (fact-iter result n n-max)
    (if (> n max-n)
        result
        (fact-iter 
            (* n result)
            (+ n 1)
            (max -n)
        )
)
```
- 递归： 先递进(展开),再回归(求值)
- 迭代： 从一个状态到下一个状态(有多个变量表示状态，每次更新这几个变量)

##### 2.1.5 more
更多精彩，尽在无尽的探索中[ANSI Common Lisp 中文翻譯版](https://acl.readthedocs.io/en/latest/index.html)


